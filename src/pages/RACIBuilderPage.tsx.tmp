
import React, { useState, useEffect, useRef } from 'react';
import { useForm, useFieldArray, useWatch } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Plus, Trash2, Download, Info, Copy } from 'lucide-react';
import { MatrixTable } from '@/components/MatrixTable';
import mermaid from 'mermaid';
import * as ExcelJS from 'exceljs';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

interface MatrixCell {
  value: string;
  color?: 'R' | 'A' | 'C' | 'I';
}

interface MatrixRow {
  taskName: string;
  cells: MatrixCell[];
}

interface MatrixData {
  headers: string[]; // ['Task', 'Role1', 'Role2', ...]
  rows: MatrixRow[];
}

// Schema for form validation
const taskSchema = z.object({
  name: z.string().min(1, 'Task name is required'),
  raci: z.record(z.string(), z.object({
    R: z.boolean(),
    A: z.boolean(),
    C: z.boolean(),
    I: z.boolean(),
  })),
});

const formSchema = z.object({
  projectName: z.string().min(1, 'Project name is required'),
  roles: z.array(z.object({ name: z.string().min(1, 'Role name is required') })).min(1, 'At least one role is required').refine(
    (roles) => new Set(roles.map((role) => role.name.toLowerCase().trim())).size === roles.length,
    { message: 'Role names must be unique (case-insensitive)' }
  ),
  tasks: z.array(taskSchema).min(1, 'At least one task is required').refine(
    (tasks) => new Set(tasks.map((task) => task.name.toLowerCase().trim())).size === tasks.length,
    { message: 'Task names must be unique (case-insensitive)' }
  ),
}).superRefine((val, ctx) => {
  const roleNames = val.roles.map((r: { name: string }) => r.name.trim()).filter(Boolean);
  if (roleNames.length === 0) {
    ctx.addIssue({ code: z.ZodIssueCode.custom, path: ['roles'], message: 'At least one role is required' });
    return;
  }
  val.tasks.forEach((_, index) => {
    const hasAccountable = roleNames.some(role => val.tasks[index].raci[role]?.A);
    if (!hasAccountable) {
      ctx.addIssue({ code: z.ZodIssueCode.custom, path: ['tasks', index], message: 'Each task must have an Accountable assigned' });
    }
    roleNames.forEach(role => {
      const assignments = val.tasks[index].raci[role];
      if (assignments) {
        const trueCount = (assignments.R ? 1 : 0) + (assignments.A ? 1 : 0) + (assignments.C ? 1 : 0) + (assignments.I ? 1 : 0);
        if (trueCount > 1) {
          ctx.addIssue({ code: z.ZodIssueCode.custom, path: ['tasks', index, 'raci', role], message: 'Only one RACI category per role' });
        }
      }
    });
  });
});

type FormData = z.infer<typeof formSchema>;

const RACIBuilderPage: React.FC = () => {
  const [matrixData, setMatrixData] = useState<MatrixData | null>(null);
  const [projectName, setProjectName] = useState<string>('');
  const [mermaidCode, setMermaidCode] = useState<string>('');
  const [mermaidSvg, setMermaidSvg] = useState<string>('');
  const [debugLogs, setDebugLogs] = useState<string[]>([]);
  const [showDebug, setShowDebug] = useState<boolean>(false);
  const mermaidRef = useRef<HTMLDivElement>(null);

  const { register, control, formState: { errors }, getValues, setValue } = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      projectName: '',
      roles: [{ name: '' }],
      tasks: [{ name: '', raci: {} }],
    },
  });

  const { fields: taskFields, append: taskAppend, remove: taskRemove } = useFieldArray({
    control,
    name: 'tasks',
  });

  const addDebugLog = (message: string) => {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${message}`;
    setDebugLogs(prev => [...prev.slice(-19), logEntry]); // Keep last 20 logs
    console.log(message); // Keep console logging too
  };

  // Add debug function to check current form values
  const debugFormValues = () => {
    const values = getValues();
    addDebugLog('üîç Current form values: ' + safeStringify(values));
  };

  // Copy debug logs to clipboard
  const copyDebugLogs = async () => {
    try {
      const logText = debugLogs.join('\n');
      await navigator.clipboard.writeText(logText);
      addDebugLog('‚úÖ Debug logs copied to clipboard!');
    } catch (error) {
      addDebugLog('‚ùå Failed to copy logs to clipboard: ' + (error instanceof Error ? error.message : String(error)));
    }
  };

  const { fields: roleFields, append: roleAppend, remove: roleRemove } = useFieldArray({
    control,
    name: 'roles',
  });

  // Override role functions to add logging and update RACI structure
  const customRoleAppend = (value: any) => {
    addDebugLog(`‚ûï Adding new role: ${JSON.stringify(value)}`);
    roleAppend(value);

    // Update RACI structure after role is added
    setTimeout(() => {
      // Get all current roles including the newly added one (use raw data to include incomplete roles for cleanup)
      const allRoles = [...watchedRolesRaw.map(r => r.name?.trim()).filter(Boolean), value.name?.trim()].filter(Boolean);
      addDebugLog(`üîÑ Updating RACI structure for all roles: [${allRoles.join(', ')}]`);
      updateRaciStructure(allRoles);
    }, 0);
  };

  const customRoleRemove = (index: number) => {
    const roleToRemove = watchedRolesRaw[index]; // Use raw data to get the actual role being removed
    addDebugLog(`üóëÔ∏è Removing role: ${JSON.stringify(roleToRemove)}`);
    roleRemove(index);

    // Update RACI structure after role is removed
    setTimeout(() => {
      const remainingRoles = watchedRolesRaw
        .filter((_, idx) => idx !== index)
        .map(r => r.name?.trim())
        .filter(Boolean);
      addDebugLog(`üîÑ Updating RACI structure after removal. Remaining roles: [${remainingRoles.join(', ')}]`);
      updateRaciStructure(remainingRoles);
    }, 0);
  };

  const watchedRolesRaw = useWatch({ control, name: 'roles' });

  // Filter out incomplete role names to prevent spurious RACI entries
  const watchedRoles = watchedRolesRaw.filter(role => {
    const roleName = role?.name?.trim() || '';
    const isIncomplete = !roleName ||
      ['R', 'A', 'C', 'I'].includes(roleName) ||
      roleName.length < 4 ||
      roleName.endsWith(' ') ||
      /^\w+\s\w{1,3}$/.test(roleName) ||
      /^\w{1,3}$/.test(roleName) ||
      roleName.includes('New Role');
    return !isIncomplete;
  });

  // Smart useEffect to clean up spurious entries without creating infinite loops
  const previousRolesRef = useRef(watchedRolesRaw);
  useEffect(() => {
    const currentRawNames = watchedRolesRaw.map(r => r.name?.trim()).filter(Boolean).sort();
    const previousRawNames = previousRolesRef.current.map(r => r.name?.trim()).filter(Boolean).sort();

    // Only trigger cleanup if the number of roles changed (add/remove), not on every keystroke
    if (currentRawNames.length !== previousRawNames.length) {
      addDebugLog(`üîÑ Role count changed (${previousRawNames.length} ‚Üí ${currentRawNames.length}), cleaning up RACI structure`);
      updateRaciStructure(currentRawNames);
    }

    previousRolesRef.current = watchedRolesRaw;
  }, [watchedRolesRaw]);

  // Function to update RACI structure when roles change
  const updateRaciStructure = (newRoles: string[]) => {
    addDebugLog(`üîß updateRaciStructure called with roles: [${newRoles.join(', ')}]`);
    const currentTasks = getValues('tasks');
    addDebugLog(`üìã Current tasks count: ${currentTasks.length}`);

    const updatedTasks = currentTasks.map(task => {
      const newRaci = { ...task.raci };

      // Add new roles that don't exist yet, but preserve existing values
      newRoles.forEach(name => {
        if (name && name.trim() && !newRaci[name]) {
          // Check if this role exists in any task with values already
          const existingRoleData = currentTasks.find(t => t.raci[name])?.raci[name];
          if (existingRoleData) {
            newRaci[name] = { ...existingRoleData };
            addDebugLog(`‚ûï Preserved existing role "${name}" with current values`);
          } else {
            newRaci[name] = { R: false, A: false, C: false, I: false };
            addDebugLog(`‚ûï Added new role "${name}" to RACI structure`);
          }
        }
      });

      // Remove old roles that are no longer in current roles OR are spurious/incomplete
      Object.keys(newRaci).forEach(key => {
        // Check if this is a spurious/incomplete role name
        const isSpurious = !key ||
          ['R', 'A', 'C', 'I'].includes(key) ||
          key.length < 4 ||
          key.endsWith(' ') ||
          /^\w+\s\w{1,3}$/.test(key) ||
          /^\w{1,3}$/.test(key) ||
          key.includes('New Role') ||
          /^\w{1,3}$/.test(key) ||
          /^.{1,3}$/.test(key);

        const shouldRemove = !newRoles.includes(key) || isSpurious;

        if (shouldRemove) {
          delete newRaci[key];
          addDebugLog(`üóëÔ∏è Removed spurious/incomplete role "${key}" from RACI structure`);
        }
      });

      return { ...task, raci: newRaci };
    });

    setValue('tasks', updatedTasks, { shouldDirty: false });
    previousRolesRef.current = watchedRoles;
    addDebugLog('‚úÖ RACI structure update completed');
  };


  const onSubmit = (cleanData: FormData) => {
    addDebugLog('üöÄ Form submission started with clean data');
    addDebugLog('üìù Clean form data: ' + safeStringify(cleanData));
    addDebugLog('üîç Checking RACI assignments...');

    // Check each task's RACI assignments
    cleanData.tasks.forEach((task) => {
      addDebugLog(`üìã Task "${task.name}" RACI assignments:`);
      Object.entries(task.raci).forEach(([roleName, raciValues]) => {
        const assignments = Object.entries(raciValues).filter(([_, value]) => value === true);
        addDebugLog(`  ${roleName}: ${assignments.map(([key]) => key).join(', ') || 'none'}`);
      });
    });

    addDebugLog('‚úÖ Validation passed! All checkbox values are booleans and RACI rules are followed');
    addDebugLog('üéâ RACI matrix generation successful!');
    setProjectName(cleanData.projectName);

    // Generate matrix data for color-coded visualization
    const allRoles = cleanData.roles.map(r => r.name.trim()).filter(Boolean);
    addDebugLog('üë• All roles: ' + JSON.stringify(allRoles));

    const matrixRows = cleanData.tasks.map(task => ({
      taskName: task.name,
      cells: allRoles.map(role => {
        const assignments = task.raci[role];
        addDebugLog(`üìã Task "${task.name}", Role "${role}": ${JSON.stringify(assignments)}`);
        if (!assignments) return { value: '', color: undefined };
        if (assignments.R) return { value: 'R', color: 'R' as const };
        if (assignments.A) return { value: 'A', color: 'A' as const };
        if (assignments.C) return { value: 'C', color: 'C' as const };
        if (assignments.I) return { value: 'I', color: 'I' as const };
        return { value: '', color: undefined };
      }),
    }));
    addDebugLog('üìä Generated matrix rows: ' + safeStringify(matrixRows));
    setMatrixData({ headers: ['Task', ...allRoles], rows: matrixRows });

    // Generate Mermaid code for flowchart (simple matrix representation)
    const roles = allRoles;
    const roleMap = new Map(roles.map((role, i) => [role, `R${i}`]));
    let code = `graph TD\n`;
    code += `    subgraph "${cleanData.projectName}"\n`;
    // Add role nodes
    roles.forEach((role) => {
      const roleId = roleMap.get(role);
      code += `        ${roleId}[${role}]\n`;
    });
    // Add task nodes and links
    cleanData.tasks.forEach((task, index) => {
      code += `        T${index}[${task.name}]\n`;
      allRoles.forEach(role => {
        const assignments = task.raci[role];
        if (assignments) {
          if (assignments.R) code += `        T${index} -->|R| ${roleMap.get(role)}\n`;
          if (assignments.A) code += `        T${index} -->|A| ${roleMap.get(role)}\n`;
          if (assignments.C) code += `        T${index} -->|C| ${roleMap.get(role)}\n`;
          if (assignments.I) code += `        T${index} -->|I| ${roleMap.get(role)}\n`;
        }
      });
    });
    code += `    end\n`;
    code += `    classDef raciRole fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n`;
    roles.forEach(role => code += `    class ${roleMap.get(role)} raciRole\n`);

    addDebugLog('üé® Generated Mermaid code:\n' + code);
    setMermaidCode(code);
    addDebugLog('‚úÖ Chart generation completed successfully');
  };

  // Safe JSON stringify that handles circular references
  const safeStringify = (obj: any) => {
    try {
      return JSON.stringify(obj, (key, value) => {
        // Skip properties that might cause circular references
        if (key === 'ref' || key === 'refs' || key.startsWith('__react')) {
          return '[Circular]';
        }
        return value;
      }, 2);
    } catch (error) {
      return '[Unable to stringify: ' + (error as Error).message + ']';
    }
  };

  const handleFormSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    addDebugLog('üì§ Form submit triggered');

    // Get current form data
    const currentFormData = getValues();
    addDebugLog('üìã Current form data: ' + safeStringify(currentFormData));

    // Clean spurious entries from the data for processing (but don't update the form)
    const cleanedData = {
      ...currentFormData,
      tasks: currentFormData.tasks.map(task => ({
        ...task,
        raci: Object.fromEntries(
          Object.entries(task.raci).filter(([roleName]) => {
            const currentRoleNames = watchedRolesRaw.map(r => r.name?.trim()).filter(Boolean);
            const isValidRole = currentRoleNames.includes(roleName);
            const isNotSpurious = roleName &&
              !['R', 'A', 'C', 'I'].includes(roleName) &&
              roleName.length >= 4 &&
              !roleName.endsWith(' ') &&
              !/^\w+\s\w{1,3}$/.test(roleName) &&
              !/^\w{1,3}$/.test(roleName) &&
              !roleName.includes('New Role');

            return isValidRole && isNotSpurious;
          })
        )
      }))
    };

    addDebugLog('üìã Cleaned data for validation: ' + safeStringify(cleanedData));

    // Validate the cleaned data manually by creating a temporary form state
    const validationResult = formSchema.safeParse(cleanedData);

    if (!validationResult.success) {
      addDebugLog('‚ùå Validation errors occurred: ' + safeStringify(validationResult.error.format()));
      addDebugLog('üí° Issue: Multiple categories selected per role');
      addDebugLog('üìã Check the "Debug Form Values" button to see current checkbox states');
      addDebugLog('üéØ Solution: Each role should have exactly ONE category: R, A, C, or I');
      addDebugLog('üìñ Example: Developer=R, Manager=A, Product Owner=C, Team Lead=I');
      return;
    }

    // If validation passes, proceed with onSubmit using cleaned data
    addDebugLog('‚úÖ Validation passed, proceeding with chart generation');
    onSubmit(cleanedData);
  };

  useEffect(() => {
    if (mermaidCode && mermaidRef.current) {
      addDebugLog('üîÑ Mermaid code changed, triggering diagram render');
      const renderMermaid = async () => {
        try {
          addDebugLog('üé® Starting Mermaid diagram rendering...');
          await mermaid.initialize({ startOnLoad: false, theme: 'default' });
          addDebugLog('üìä Mermaid initialized, rendering diagram...');
          const { svg } = await mermaid.render('mermaid-diag', mermaidCode);
          setMermaidSvg(svg);
          addDebugLog('‚úÖ Mermaid diagram rendered successfully');
        } catch (error) {
          addDebugLog('‚ùå Mermaid rendering error: ' + (error instanceof Error ? error.message : String(error)));
          console.error('Mermaid rendering error:', error);
        }
      };
      renderMermaid();
    }
  }, [mermaidCode]);

  const handleXLSXExport = async () => {
    if (!matrixData || !projectName) return;
  
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('RACI Matrix');
  
    const date = new Date().toLocaleDateString();
    const headerText = `Project: ${projectName} | Date: ${date}`;
    const fullHeaders = matrixData.headers;
    const fullRows = matrixData.rows.map(row => [row.taskName, ...row.cells.map(cell => cell.value || '')]);

    // Add header row (subtle indigo for title)
    const headerRow = worksheet.addRow([headerText]);
    headerRow.font = { bold: true, color: { argb: 'FF1E40AF' }, size: 14 };
    headerRow.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE0E7FF' } }; // light indigo
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.eachCell((cell) => {
      cell.border = {
        top: { style: 'thin', color: { argb: 'FF000000' } },
        bottom: { style: 'thin', color: { argb: 'FF000000' } },
        left: { style: 'thin', color: { argb: 'FF000000' } },
        right: { style: 'thin', color: { argb: 'FF000000' } }
      };
    });

    // Merge header row across all columns
    worksheet.mergeCells(1, 1, 1, fullHeaders.length);

    // Add column headers (subtle gray only for role cells, white for Task)
    const headerCellsRow = worksheet.addRow(fullHeaders);
    headerCellsRow.font = { bold: true, color: { argb: 'FF374151' } }; // dark gray text
    headerCellsRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerCellsRow.eachCell((cell, colNumber) => {
      if (colNumber > 1) { // Role columns (skip Task column)
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF9FAFB' } }; // light gray
      } // Task column remains default white
      cell.border = {
        top: { style: 'thin', color: { argb: 'FF000000' } },
        bottom: { style: 'thin', color: { argb: 'FF000000' } },
        left: { style: 'thin', color: { argb: 'FF000000' } },
        right: { style: 'thin', color: { argb: 'FF000000' } }
      };
    });
  
    // Add data rows
    const dataBorder: Partial<ExcelJS.Borders> = {
      top: { style: 'thin', color: { argb: 'FF000000' } },
      bottom: { style: 'thin', color: { argb: 'FF000000' } },
      left: { style: 'thin', color: { argb: 'FF000000' } },
      right: { style: 'thin', color: { argb: 'FF000000' } }
    };
    fullRows.forEach((rowData) => {
      const row = worksheet.addRow(rowData);
      row.eachCell((cell, colNumber) => {
        const cellValue = rowData[colNumber - 1];
        const cellColor = cellValue as 'R' | 'A' | 'C' | 'I' | '';
        let fillColor = { argb: 'FFFFFFFF' }; // white default
        if (cellColor === 'R') fillColor = { argb: 'FFD1FAE5' }; // light green
        else if (cellColor === 'A') fillColor = { argb: 'FFFEF3C7' }; // light amber
        else if (cellColor === 'C') fillColor = { argb: 'FFD6E4FF' }; // light blue
        else if (cellColor === 'I') fillColor = { argb: 'FFF3F4F6' }; // light gray
        cell.font = { bold: cellColor !== '' };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: fillColor };
        cell.alignment = { horizontal: 'center', vertical: 'middle', wrapText: true };
        cell.border = dataBorder;
      });
    });

    // Auto-fit column widths based on content
    const maxLengths = fullHeaders.map((_, colIndex) => {
      let maxLen = fullHeaders[colIndex].length;
      fullRows.forEach(rowData => {
        const cellValue = rowData[colIndex];
        maxLen = Math.max(maxLen, (cellValue || '').length);
      });
      return Math.max(maxLen, 8) + 2;
    });
    worksheet.columns = maxLengths.map(width => ({ width }));
  
    // Write to buffer and download
    const buffer = await workbook.xlsx.writeBuffer();
    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'raci-formatted.xlsx';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };
    
    const handleRawXLSXExport = async () => {
      if (!matrixData || !projectName) return;
    
      const workbook = new ExcelJS.Workbook();
      const worksheet = workbook.addWorksheet('RACI Raw');
    
      const date = new Date().toLocaleDateString();
      const headerText = `Project: ${projectName} | Date: ${date}`;
      const fullHeaders = matrixData.headers;
      const fullRows = matrixData.rows.map(row => [row.taskName, ...row.cells.map(cell => cell.value || '')]);
    
      // Add header row
      worksheet.addRow([headerText]);
    
      // Add column headers
      worksheet.addRow(fullHeaders);
    
      // Add data rows
      fullRows.forEach(rowData => worksheet.addRow(rowData));
    
      // Write to buffer and download
      const buffer = await workbook.xlsx.writeBuffer();
      const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'raci-raw.xlsx';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    };
    
    const handlePDFExport = async () => {
      if (!matrixData || !projectName) return;

      const doc = new jsPDF();
  
      const date = new Date().toLocaleDateString();
      const title = `Project: ${projectName} | Date: ${date}`;
      doc.setFontSize(16);
      doc.setFont('helvetica', 'bold');
      doc.text(title, 14, 20);
  
      const fullHeaders = matrixData.headers;
      const fullRows = matrixData.rows.map(row => [row.taskName, ...row.cells.map(cell => cell.value || '')]);
  
      // Compute max content lengths for column widths
      const maxLengths = fullHeaders.map((_, colIndex) => {
        let maxLen = fullHeaders[colIndex].length;
        fullRows.forEach(rowData => {
          const cellValue = rowData[colIndex];
          maxLen = Math.max(maxLen, (cellValue || '').length);
        });
        return Math.max(30, maxLen * 5 || 10);
      });
  
      autoTable(doc, {
        head: [fullHeaders],
        body: fullRows,
        theme: 'grid',
        startY: 30,
        headStyles: {
          fillColor: [249, 250, 251], // light gray
          textColor: [55, 65, 81], // dark gray
          fontStyle: 'bold',
          fontSize: 12,
          halign: 'center',
          valign: 'middle',
          lineWidth: 0.5,
          lineColor: [0, 0, 0]
        },
        bodyStyles: {
          fontSize: 10,
          halign: 'center',
          valign: 'middle',
          lineWidth: 0.5,
          lineColor: [0, 0, 0]
        },
        columnStyles: fullHeaders.reduce((styles, _, index) => {
          styles[index] = { cellWidth: maxLengths[index] };
          return styles;
        }, {} as { [key: string]: Partial<any> }),
        didDrawCell: function (data: any) {
          const row = data.row.index;
          const col = data.column.index;
          if (row === 0) { // head row: white for Task, light gray for roles
            if (col === 0) {
              data.cell.styles.fillColor = [255, 255, 255]; // white for Task
            } else {
              data.cell.styles.fillColor = [249, 250, 251]; // light gray for roles
            }
            data.cell.styles.fontStyle = 'bold';
            return;
          }
  
          const cellValue = fullRows[row - 1][col];
          let fillColor = [255, 255, 255]; // white
          if (cellValue === 'R') fillColor = [209, 250, 229]; // light green
          else if (cellValue === 'A') fillColor = [254, 243, 199]; // light amber
          else if (cellValue === 'C') fillColor = [214, 228, 255]; // light blue
          else if (cellValue === 'I') fillColor = [243, 244, 246]; // light gray
  
          data.cell.styles.fillColor = fillColor;
          data.cell.styles.fontStyle = cellValue !== '' ? 'bold' : 'normal';
        },
        margin: { top: 25, left: 14, right: 14 }
      });

      // Add Mermaid diagram as image
      if (mermaidRef.current) {
        const canvas = await html2canvas(mermaidRef.current, { scale: 2 });
        const imgData = canvas.toDataURL('image/png');
        const imgProps = doc.getImageProperties(imgData);
        const pdfWidth = doc.internal.pageSize.getWidth();
        const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
        doc.addPage();
        doc.addImage(imgData, 'PNG', 14, 30, pdfWidth - 28, pdfHeight);
      }

      doc.save('raci-formatted.pdf');
    };

  const handleSVGDownload = () => {
    if (mermaidSvg) {
      const svgBlob = new Blob([mermaidSvg], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'raci-chart.svg';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  };

  // Generic handler for checkbox changes to reduce duplication
  const handleCheckboxChange = (
    taskIndex: number,
    roleName: string,
    category: 'R' | 'A' | 'C' | 'I',
    checked: boolean
  ) => {
    addDebugLog(`üìã Checkbox clicked: ${roleName}.${category} = ${checked}`);

    if (checked) {
      // Uncheck other categories for this role
      const otherCategories = ['R', 'A', 'C', 'I'].filter(c => c !== category);
      otherCategories.forEach(otherCat => {
        const otherPath = `tasks.${taskIndex}.raci.${roleName}.${otherCat}`;
        setValue(otherPath as any, false, {
          shouldValidate: false,
          shouldDirty: true
        });
      });
      addDebugLog(`üîÑ Unchecked other categories for ${roleName} (RACI rule)`);
    }

    const path = `tasks.${taskIndex}.raci.${roleName}.${category}`;
    setValue(path as any, checked, {
      shouldValidate: false,
      shouldDirty: true
    });

    // Verify the value was set correctly
    setTimeout(() => {
      const currentValue = getValues(path as any);
      addDebugLog(`‚úÖ ${roleName}.${category} set to: ${currentValue} (expected: ${checked})`);
    }, 0);
  };

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-4xl mx-auto px-4">
        <Card>
          <CardHeader>
            <div className="flex items-center gap-2">
              <CardTitle className="text-2xl font-bold">RACI Chart Builder</CardTitle>
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="ghost" size="sm" className="p-1 h-6 w-6">
                      <Info className="h-4 w-4 text-blue-600" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent className="max-w-sm">
                    <div className="space-y-2">
                      <div>
                        <p className="font-semibold">RACI Categories:</p>
                        <ul className="list-disc list-inside ml-2 space-y-1 text-sm">
                          <li><strong>R (Responsible):</strong> Person who does the work</li>
                          <li><strong>A (Accountable):</strong> Person ultimately answerable (one per task)</li>
                          <li><strong>C (Consulted):</strong> People whose opinions are sought</li>
                          <li><strong>I (Informed):</strong> People who need to be kept in the loop</li>
                        </ul>
                      </div>
                      <div>
                        <p className="font-semibold">Validation Rules:</p>
                        <ul className="list-disc list-inside ml-2 space-y-1 text-sm">
                          <li>Every task must have <strong>exactly one</strong> Accountable person</li>
                          <li><strong>Each role can only be assigned one RACI category per task</strong></li>
                          <li>All role names must be unique</li>
                          <li>All task names must be unique</li>
                        </ul>
                      </div>
                      <div className="bg-yellow-50 p-2 rounded text-xs">
                        <strong>Example:</strong> For a task, you might assign:<br/>
                        Developer: R (Responsible)<br/>
                        Project Manager: A (Accountable)<br/>
                        Product Owner: C (Consulted)<br/>
                        Team Lead: I (Informed)
                      </div>
                    </div>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
            <p className="text-gray-600">Define roles and tasks to generate a RACI matrix for your projects.</p>
          </CardHeader>
          <CardContent>
            {/* Validation Errors Summary */}
            {Object.keys(errors).length > 0 && (
              <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg">
                <h3 className="text-lg font-semibold text-red-800 mb-2">Validation Errors</h3>
                <div className="text-sm text-red-700 space-y-1">
                  {errors.projectName && <p>‚Ä¢ Project name: {errors.projectName.message}</p>}
                  {errors.roles && <p>‚Ä¢ Roles: {errors.roles.message}</p>}
                  {errors.tasks && typeof errors.tasks.message === 'string' && <p>‚Ä¢ Tasks: {errors.tasks.message}</p>}
                  {errors.tasks && Array.isArray(errors.tasks) && errors.tasks.map((taskError, index) => (
                    taskError && (
                      <div key={index}>
                        <p className="font-medium">Task {index + 1}:</p>
                        {taskError.name && <p className="ml-4">‚Ä¢ Name: {taskError.name.message}</p>}
                        {taskError.message && <p className="ml-4">‚Ä¢ {taskError.message}</p>}
                        {taskError.raci && Object.entries(taskError.raci).map(([roleName, roleError]) => (
                          <div key={roleName} className="ml-4">
                            {roleError && typeof roleError === 'object' && 'message' in roleError && typeof roleError.message === 'string' ? (
                              <p>‚Ä¢ {roleName}: {roleError.message}</p>
                            ) : roleError && typeof roleError === 'object' && !('message' in roleError) ? (
                              // Handle nested RACI category errors
                              <div>
                                <p className="font-medium">‚Ä¢ {roleName}:</p>
                                {Object.entries(roleError).map(([category, categoryError]) => (
                                  categoryError && typeof categoryError === 'object' && 'message' in categoryError && typeof categoryError.message === 'string' && (
                                    <p key={category} className="ml-6">‚Ä¢ {category}: {categoryError.message}</p>
                                  )
                                ))}
                              </div>
                            ) : null}
                          </div>
                        ))}
                      </div>
                    )
                  ))}
                </div>
              </div>
            )}

            <form onSubmit={handleFormSubmit} className="space-y-6">
              <div>
                <Label htmlFor="projectName">Project Name</Label>
                <Input id="projectName" {...register('projectName')} />
                {errors.projectName && <p className="text-red-500 text-sm">{errors.projectName.message}</p>}
              </div>

              <div>
                <h3 className="text-lg font-semibold mb-2">Roles</h3>
                {roleFields.map((field, index) => (
                  <div key={field.id} className="border p-4 mb-4 rounded flex gap-2 items-center">
                    <Input
                      placeholder="e.g. Developer, Project Manager, Product Owner"
                      {...register(`roles.${index}.name` as const)}
                      className="flex-1 text-gray-500 placeholder:text-gray-400 focus:placeholder:text-transparent"
                      onFocus={(e) => {
                        if (e.target.placeholder && !e.target.value) {
                          e.target.placeholder = '';
                        }
                      }}
                      onBlur={(e) => {
                        if (!e.target.value) {
                          e.target.placeholder = 'e.g. Developer, Project Manager, Product Owner';
                        }
                      }}
                    />
                    <Button type="button" variant="outline" onClick={() => customRoleRemove(index)} size="sm">
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                ))}
                {errors.roles && <p className="text-red-500 text-sm">{errors.roles.message}</p>}
                <Button type="button" onClick={() => {
                  addDebugLog('üîò Add Role button clicked');
                  customRoleAppend({ name: '' });
                }} className="mb-4">
                  <Plus className="h-4 w-4 mr-2" /> Add Role
                </Button>
              </div>

              <div>
                <h3 className="text-lg font-semibold mb-2">Tasks</h3>
                {taskFields.map((field, index) => (
                  <div key={field.id} className="border p-4 mb-4 rounded">
                    <div className="flex gap-2 items-center mb-2">
                      <Input
                        placeholder="Task Name"
                        {...register(`tasks.${index}.name` as const)}
                        className="flex-1"
                      />
                      <Button type="button" variant="outline" onClick={() => taskRemove(index)} size="sm">
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                    {errors.tasks?.[index]?.name && <p className="text-red-500 text-sm">{errors.tasks?.[index]?.name?.message}</p>}
                    {errors.tasks?.[index] && <p className="text-red-500 text-sm">{errors.tasks[index]?.message}</p>}
                    <div className="space-y-2">
                      <div className="text-xs text-gray-600 mb-2 bg-blue-50 p-2 rounded">
                        üí° <strong>RACI Rule:</strong> Select only ONE category per role (R/A/C/I)
                      </div>
                      {roleFields.map((roleField, roleIndex) => {
                        const role = watchedRolesRaw[roleIndex]; // Use raw data for rendering all roles
                        const roleName = role?.name?.trim() || '';

                        // Check if this role is filtered out (incomplete)
                        const isFilteredOut = !watchedRoles.some(filteredRole =>
                          filteredRole.name?.trim() === roleName
                        );

                        if (isFilteredOut) {
                          return (
                            <div key={roleField.id} className="flex gap-2 items-center opacity-50">
                              <Label className="w-24 font-medium text-gray-400">
                                {roleName || `Role ${roleIndex + 1}`} (incomplete)
                              </Label>
                              <div className="flex gap-2 text-xs text-gray-400">
                                Complete role name to enable checkboxes
                              </div>
                            </div>
                          );
                        }

                        // Check if this role already has a category selected for this task
                        const currentAssignments = getValues(`tasks.${index}.raci.${roleName}`);
                        const hasCategorySelected = currentAssignments?.R || currentAssignments?.A || currentAssignments?.C || currentAssignments?.I;

                        return (
                          <div key={roleField.id} className="flex gap-2 items-center">
                            <Label className="w-24 font-medium">{roleName}</Label>
                            <div className="flex gap-2">
                              <div className="flex items-center gap-1">
                                <Checkbox
                                  {...register(`tasks.${index}.raci.${roleName}.R` as const)}
                                  disabled={hasCategorySelected && !currentAssignments?.R}
                                  onCheckedChange={(checked) => handleCheckboxChange(index, roleName, 'R', checked as boolean)}
                                />
                                <Label className={`text-sm ${hasCategorySelected && !currentAssignments?.R ? 'text-gray-400' : ''}`}>Responsible</Label>
                              </div>
                              <div className="flex items-center gap-1">
                                <Checkbox
                                  {...register(`tasks.${index}.raci.${roleName}.A` as const)}
                                  disabled={hasCategorySelected && !currentAssignments?.A}
                                  onCheckedChange={(checked) => handleCheckboxChange(index, roleName, 'A', checked as boolean)}
                                />
                                <Label className={`text-sm ${hasCategorySelected && !currentAssignments?.A ? 'text-gray-400' : ''}`}>Accountable</Label>
                              </div>
                              <div className="flex items-center gap-1">
                                <Checkbox
                                  {...register(`tasks.${index}.raci.${roleName}.C` as const)}
                                  disabled={hasCategorySelected && !currentAssignments?.C}
                                  onCheckedChange={(checked) => handleCheckboxChange(index, roleName, 'C', checked as boolean)}
                                />
                                <Label className={`text-sm ${hasCategorySelected && !currentAssignments?.C ? 'text-gray-400' : ''}`}>Consulted</Label>
                              </div>
                              <div className="flex items-center gap-1">
                                <Checkbox
                                  {...register(`tasks.${index}.raci.${roleName}.I` as const)}
                                  disabled={hasCategorySelected && !currentAssignments?.I}
                                  onCheckedChange={(checked) => handleCheckboxChange(index, roleName, 'I', checked as boolean)}
                                />
                                <Label className={`text-sm ${hasCategorySelected && !currentAssignments?.I ? 'text-gray-400' : ''}`}>Informed</Label>
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))}
                <Button type="button" onClick={() => {
                  const currentRoles = getValues('roles').map(r => r.name.trim()).filter(Boolean);
                  const newRaci = Object.fromEntries(
                    currentRoles.map(roleName => [roleName, { R: false, A: false, C: false, I: false }])
                  );
                  taskAppend({ name: '', raci: newRaci });
                }}>
                  <Plus className="h-4 w-4 mr-2" /> Add Task
                </Button>
              </div>

              <div className="flex gap-2">
                <Button type="button" variant="outline" onClick={debugFormValues}>
                  üîç Debug Form Values
                </Button>
                <Button type="submit">Generate RACI Chart</Button>
              </div>
            </form>

            {(matrixData || mermaidSvg) && (
              <div className="mt-8">
                {matrixData && (
                  <>
                    <h3 className="text-lg font-semibold mb-2">RACI Matrix</h3>
                    <MatrixTable data={matrixData} />
                  </>
                )}
                {mermaidSvg && (
                  <>
                    <h3 className="text-lg font-semibold mb-2">Mermaid Diagram</h3>
                    <div ref={mermaidRef} dangerouslySetInnerHTML={{ __html: mermaidSvg }} className="mermaid" />
                    <pre className="mt-4 p-4 bg-gray-100 rounded text-sm overflow-auto">{mermaidCode}</pre>
                 